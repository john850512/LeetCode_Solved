# 1191. K-Concatenation Maximum Sum
### Approache 1. brute force + kadane's algo
把arr全部拼起來做，會TLE，因為資料10^5，k10^4弄一弄就爆炸了

#### Approach 2. kadane's algo
kadane's的應用，要考慮下面幾種case:  

k == 1: 單一陣列的kadane's algo問題

k >= 2時:
##### 如果單一array sum <= 0，則**越多的array並不會有任何好處**，就想成有兩條array來做一次kadane's algo即可
- 在此case下有兩種可能，max sub array 在單一個array的中間，或是在一條的尾部和另一條的頭部，不過如果把array接起來做就可以一併處理
- 或是要考慮 circular array的那種題型，透過 max(total - min_sub_array, max_sub_array)來求
##### 如果array sum > 0，則越多的array有助於增加答案的值
假設arr長[(A)(B)(C)][(A)(B)(C)]...[(A)(B)(C)][(A)(B)(C)]
- (A) (B) (C) 可能是一段數字或一個數字
- 可先把上述的問題轉換成[(A)(B)(C)] + (k-2)*total_sum + [(A)(B)(C)] 

1.如果單一array的maximum sum subarray為B，則最前面的陣列必須要取後綴(B)(C)，而後面的陣列必須要取前綴(A)(B)，所以式子會變成:

(B)(C) + (k-2)*total_sum + (A)(B) = (A)(B)(C) + (B) + (k-2)*total_sum = (k-1)*total_sum + (B)

- = (k-1)*total_sum + 單一陣列的kadane's algo

2.如果單一array的maximum sum subarray為A或C?
- 那答案就會是[(A)(B)(C)]...[(A)(B)(C)] + (A) 或 (C) + [(A)(B)(C)]...[(A)(B)(C)][(A)(B)(C)] 
- = (k-1)*total_sum + 單一陣列的kadane's algo

3.如果maximum sum subarray為A+C(陣列的尾部+下一段陣列的頭部)?
- 不會有這種情況，這題並不是circular subarray


分析:
- time complexity: O(N)
- space complexity: O(1)
```c++
class Solution {
public:
    int kConcatenationMaxSum(vector<int>& arr, int k) {
        if(arr.empty()) return 0;
        long long temp_max, max_so_far, total;
        
        temp_max = max_so_far = total = 0;
        for(int i = 0 ; i < arr.size() ; i++){
            temp_max = max(temp_max + arr[i], (long long int)arr[i]);
            max_so_far = max(max_so_far, temp_max);
            
            total += arr[i];
        }
        if(k == 1) {
            return max_so_far % (long long)(1e9 + 7);
        }
        else{
            if(total <= 0){
                for(int i = 0 ; i < arr.size() ; i++){
                    temp_max = max(temp_max + arr[i], (long long)arr[i]);
                    max_so_far = max(max_so_far, temp_max);
                }
                return max_so_far % (long long)(1e9 + 7);
            }
            else{
                return ((k-1) * total + max_so_far) % (long long)(1e9 + 7);
            }
        }
    }
};
```
