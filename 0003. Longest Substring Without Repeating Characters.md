# 3. Longest Substring Without Repeating Characters
注意兩個special case:
1. 空字串
2. 如果到子字串結尾==字串結尾的情況

#### Approach 1: Brute force
對於每一個字元，去檢查在前面合法的子字串中是否存在，若不存在則增加子字串長度，若存在則重新搜尋
分析:
- Time Complexity: O(N)， N is length of string
- Space Complexity: O(k)，k is check size

#### Approach 2: Sliding window
透過一個check array去檢查該字元前面是否出現過了，並用兩個index紀錄window range
分析:
- Time Complexity: O(N)， N is length of string
- Space Complexity: O(k)，k is check size
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int ans=1;
        int i=0, j=0, maxlen=1;
        int check[150] = {0};
        
        // special case: when string is empty
        if(s.size() == 0) return 0;
        while(j < s.size()){
            //printf("*%d %d %d \n",i, j, check[s[j]]);
            if(check[s[j]] == 0){
                check[s[j]] = 1;
                j++;
            }
            else{
                maxlen = j-i > maxlen ? j-i : maxlen;
                //printf("%d %d %d\n", i, j, maxlen);
                i++;
                j=i;
                memset(check, 0, sizeof(check));
            }
        }
        
        // special case: when j is tail of string
        maxlen = j-i > maxlen ? j-i : maxlen;
        return maxlen;
    }
};
```

#### Approach 3: Sliding window
一樣是sliding window, 但不用每次都重算, 當發現重複的時候從上一個重複的紀錄點開始重算即可
透過一個arr紀錄每個char的重算idx(當前位置的下一個)
更新l, r point來掃過這個string, 並不斷的紀錄最長的sub string len
(ref: https://yuihuang.com/lc-3/)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int tb_next_idx[128] = {0};
        int max_len = 0;

        for(int r=0, l=0; r<s.size(); r++) {
            l = max(tb_next_idx[s[r]], l);
            max_len = max(max_len, r-l+1);
            tb_next_idx[s[r]] = r+1;
        }

        return max_len;
    }
};
```




